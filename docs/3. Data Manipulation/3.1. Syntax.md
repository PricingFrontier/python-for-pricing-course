# 3.1. Syntax

## Variables and Data Types

Values can be stored as python variables, these can simply be numbers, strings, booleans, or can be more complex such as lists, arrays, dictionaries, whole datasets, models, etc. 

```python
# Example variables
minimum_premium_new_business = 100.00   # float
model_response = 'ClaimCount'           # string
renewal_flag = True                     # boolean
```

## Basic Operations
```python
# Calculations
loss_ratio = total_incurred_losses / net_earned_premium
```

```python
# f strings
database = 'SQL001'
schema = 'pricing'
table = 'modelling_data'

# use 'f' before a string, and {} braces to include variables within a string
query = f'select * from [{database}].[{schema}].[{table}]'
# 'select * from [SQL001].[pricing].[modelling_data]'

```
## Lists

Lists are groups of Python objects. They are ordered, indexable, and can be looped through or manipulated.

```python
features = [
    'DriverAge',
    'LicenceLength',
    'VehicleAge',
    'VehicleValue'
]

net_earned_premiums = [
    42.44,
    129.98,
    87.49,
    54.34,
    210.85
]

# Indexing
print(features[0])   # "DriverAge"
print(net_earned_premiums[-1])  # 210.85 (last item)
```

## Dictionaries 
Dictionaries store Python objects using key-value pairs. Keys are strings, while values can be any object (numbers, strings, lists, other dictionaries).

```python
# keys on the left are features, values on the right are feature type
feature_config = {
    'DriverAge': 'continuous',
    'LicenceLength': 'continuous',
    'VehicleType': 'categorical',
    'VehicleAge': 'continuous',
    'VehicleValue': 'continuous',
    'ClassOfUse': 'categorical'
}
```

They can be programmatically assigned as so:

```python
feature_config = {}
feature_config[key] = value
```

Values can be retrieved as so:

```python
feature_type = feature_config.get('DriverAge')
print(feature_type) # "continuous"
```

Dictionaries can be nested, making them useful for storing model configurations, hyperparameters, or mappings between codes and descriptions.

## Conditions

If/else statements are used to code to run under some conditions, and different code to run under a different set.

```python
if renewal_flag == True:
    print('The policy is a renewal')
else:
    print('The policy is a new business')
```

## Loops

Used to iterate through lists or dictionaries, repeating code for each item.

```python
for feature in features:
    feature_type = feature_config.get(feature)

    if feature_type == 'continuous':
        data = band_continuous(data, feature)
```

## Abstraction

Abstraction is when we put more complex logic into functions, classes or libraries, allowing us to use a simple interface to write out code.

Rather than writing single complicated scripts, by creating functions for each task, we can simplify the overall workflow, promoting reusability across the codebase.

In the below example, a function called 'calculate_burning_costs' is created, with the arguments 'claims' and 'exposure'. This performs a calculation and returns the results.

```python
def calculate_burning_cost(claims, exposure):
    """Return burning cost = claims / exposure"""
    return claims / exposure

# Example usage
claims = 120000
exposure = 1500  # car-years
print(calculate_burning_cost(claims, exposure))  # 80.0
```

## Configuration

Rather than hardcoding numbers, we store them in configuration files or dictionaries.
This allows analysts to change parameters without editing core logic, or to use shared modules with different parameters.

```python
pricing_config = {
    'MinimumPremium': 100.0
}

def apply_pricing_rules(premium, config):
    premium = max(premium, config['MinimumPremium'])
    return premium

print(apply_pricing_rules(80, pricing_config))  # 100.0
```