# 5.3. Model Registries

Model registries are centralized repositories that allow teams to store, version, and manage machine learning models throughout their lifecycle. Using a model registry ensures that models are traceable, auditable, and reproducible, which is critical in insurance pricing where models directly impact financial decisions.

---

## Why Use a Model Registry?

Model registries provide several benefits:

- Version Control – Every model version is tracked, so you can reproduce results from any point in time.  
- Lifecycle Management – Manage stages like `Staging`, `Production`, `Archived` to control which models are actively used.  
- Auditability & Governance – Maintain a full history of who created or approved a model and when.  
- Collaboration – Teams can share models easily without confusion over which version is current.  
- Integration – Models can be pulled directly into scoring pipelines or deployed APIs reliably.

In pricing teams, this prevents “key man” risk, ensures regulatory compliance, and allows smooth transitions between analysts or teams.

---


## How should you access the models in the registry?

Access models either through MLflow's UI for a visual interface or programmatically for automation and integration into other applications:

```python
import mlflow
client = mlflow.tracking.MlflowClient()
model_versions = client.search_model_versions("name='bikes'")
for model_version in model_versions:
    print(model_version)
```

## How should you mark your model as ready to production?

To effectively manage MLflow models, especially when marking a model as ready for production, using [aliases](https://mlflow.org/docs/latest/model-registry.html#deploy-and-organize-models-with-aliases-and-tags) is a highly practical approach. This method allows for a flexible handling of model versions, which can change frequently with new training runs or during model rollbacks.

[Model aliases](https://mlflow.org/docs/latest/model-registry.html#deploy-and-organize-models-with-aliases-and-tags) in MLflow are mutable, named references that can be assigned to specific versions of a registered model. This allows you to reference a model version using a model URI or through the model registry API without constantly updating the version number. For example, you can create an alias named "champion" that points to version 1 of a model called "MyModel." Subsequently, this model version can be referred to with the URI models:/MyModel@champion.

### Assigning an Alias

You can assign an alias through the MLflow UI or programmatically. Here’s how you can do it programmatically:

```python
from mlflow.tracking import MlflowClient

client = MlflowClient(tracking_uri="./mlruns", registry_uri="./mlruns")
client.set_registered_model_alias(name="bikes", alias="Champion", version=1)
```

### Retrieving a Model Using an Alias

To use the model assigned to an alias in your applications, you can retrieve it as follows:

```python
import mlflow

model_uri = "models:/bikes@Champion"
model = mlflow.pyfunc.load_model(model_uri=model_uri)
predictions = model.predict(inputs)
```

### Automating Alias Assignment

To automate the assignment of an alias to the latest model version, you can use:

```python
versions = client.search_model_versions("name='bikes'", max_results=1, order_by=["version_number DESC"])
last_version = versions[0].version
client.set_registered_model_alias(name="bikes", alias="Champion", version=last_version)
```

## How can you rollback your model if something goes wrong?

To rollback a model version in MLflow, you can reassign the alias to a previous stable version either through the UI or programmatically. Remember, after rolling back, you'll need to refresh the model loading in your application either manually or set it up to automatically detect changes.

## How can you define custom logic associated with your model?

MLflow supports a customizable model format called ["PyFunc" (Python Function)](https://mlflow.org/docs/latest/python_api/mlflow.pyfunc.html), which allows you to define custom logic that executes in conjunction with your model. Here's how you can utilize PyFunc to integrate custom logic with your model:

```python
import mlflow.pyfunc

class CustomModel(mlflow.pyfunc.PythonModel):

    def load_context(self, context):
        # Load artifacts or dependencies here
        pass

    def predict(self, context, model_input):
        # Apply custom logic here
        return model_input.apply(some_transformation)

# Example of saving the model
mlflow.pyfunc.save_model(path="path/to/save", python_model=CustomModel())
```

This example defines a custom model by subclassing [`mlflow.pyfunc.PythonModel`](https://mlflow.org/docs/latest/python_api/mlflow.pyfunc.html#mlflow.pyfunc.PythonModel) and implementing the necessary methods to integrate custom behavior during model predictions.

## Model Registry additional resources

- **[Model Registry integration from the MLOps Python Package](https://github.com/fmind/mlops-python-package/blob/main/src/bikes/io/registries.py)**
- [MLflow Model Registry](https://mlflow.org/docs/latest/model-registry.html)
- [MLflow Model Registry Example](https://docs.databricks.com/en/_extras/notebooks/source/mlflow/mlflow-model-registry-example.html)

