# 6.5. Infrastructure as Code

Infrastructure as Code (IaC) means configuring cloud services and infrastructure using code, rather than manually pointing and clicking in a web console.  

The configuration lives in version-controlled code, right alongside the application or model code it supports which makes your infrastructure repeatable, auditable, and automated.

---

## Why use IaC?

- Consistency – ensure every environment (dev, test, prod) is set up identically.  
- Automation – spin up or tear down infrastructure with a single command.  
- Speed – new environments for models, APIs, or experiments can be created in minutes.  
- Versioning – infrastructure changes are tracked in Git, just like application code.  
- Collaboration – analysts and engineers can share the same definitions for how systems should run.  

---

## Example in Pricing

A pricing team wants to deploy a new CatBoost model into production:  

- With IaC, the cloud resources (compute instance, container registry, storage, networking) are defined in code.  
- The same code can create a test environment for validation, and later a production environment for live deployment.  
- If more compute power is needed, the configuration file can be updated and reapplied - no manual reconfiguration required.  

---

## Terraform

[Terraform](https://developer.hashicorp.com/terraform) is one of the most popular IaC tools. It uses configuration files (`.tf`) to define infrastructure in a cloud-agnostic way.  

---

## Example Terraform File

```terraform
# Define the provider (Azure in this case)
provider "azurerm" {
  features {}
}

# Resource group for pricing models
resource "azurerm_resource_group" "pricing" {
  name     = "pricing-rg"
  location = "UK South"
}

# Container instance to run our model API
resource "azurerm_container_group" "pricing_model" {
  name                = "pricing-model-api"
  location            = azurerm_resource_group.pricing.location
  resource_group_name = azurerm_resource_group.pricing.name
  os_type             = "Linux"

  container {
    name   = "model"
    image  = "myregistry.azurecr.io/pricing-model:latest"
    cpu    = "2"
    memory = "4"

    ports {
      port     = 8080
      protocol = "TCP"
    }
  }

  ip_address {
    type = "Public"
    ports {
      port     = 8080
      protocol = "TCP"
    }
  }
}
```

The above code: 

## 1. Provider Configuration

- Configures Terraform to use the Azure provider.
- Sets the Azure subscription ID and tenant ID via variables, allowing Terraform to authenticate to the correct Azure environment.

## 2. Resource Group

- Creates a Resource Group, which is a container for all other Azure resources.
- Groups all resources together for easier management and billing.

## 3. Azure Container Registry (ACR)

- Creates a private container registry to store Docker images.
- Uses a basic SKU and enables admin access for Terraform to authenticate and push or pull images.

## 4. Log Analytics Workspace

- Sets up a workspace for collecting logs and metrics.
- Required for monitoring Container Apps environments.
- Logs are retained for a defined period (e.g., 30 days).

## 5. Container App Environment

- Creates a Container App Environment, which is a sandboxed environment for running Azure Container Apps.
- Links the environment to the Log Analytics workspace for observability.

## 6. Container App Deployment

- Deploys a FastAPI container within the Container App Environment.
- Specifies CPU and memory allocation for the container.
- Connects the app to the private container registry for pulling the Docker image.
- Uses secrets for securely storing registry credentials.
- Configures external ingress, exposing the app to the internet on a specified port.
- Sets the traffic routing so that all requests go to the latest app revision.

## 7. Outputs

- Provides the login URL of the container registry, so images can be managed.
- Provides the public URL of the deployed FastAPI app for use in CI/CD pipelines, testing, or integration with other systems.
