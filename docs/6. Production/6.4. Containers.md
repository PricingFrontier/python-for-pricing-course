# 6.4. Containers

A container is a lightweight, portable package that includes your application and everything it needs to run - code, libraries, dependencies, and configuration.  

[Docker](https://www.docker.com/) is the most widely used container technology.

Instead of worrying about whether code will behave differently on your laptop, a server, or in the cloud, containers guarantee that your application runs the same way everywhere.

---

## Why use Containers in Pricing & Analytics?

- Consistency – no more "it worked on my machine" problems.  
- Portability – run the same model or pipeline locally, in testing, and in production without change.  
- Isolation – dependencies are separated, so one project's setup won't break another.  
- Scalability – containers can be replicated to handle large volumes (e.g. running impact analysis across millions of quotes).  
- Integration – containers slot neatly into CI/CD pipelines for smooth deployment.  

---

## Workflow with Docker

1. Write your code – e.g. Python scripts for data prep and model training.  
2. Create a Dockerfile – specify Python version, required packages, and how to run the app.  
3. Build the container – package everything into a single Docker image.  
4. Run it anywhere – locally, on a server, or in the cloud.  
5. Deploy at scale – containers can be managed with orchestration tools like Kubernetes or Azure Container Apps.  

---

## Installing Docker

The likeliest scenario will be installing Docker on Windows, and using WSL as a backend. 

The documentation for this can be found [here](https://docs.docker.com/desktop/features/wsl/)

## Example Dockerfile (Python model)

```dockerfile
# Use a lightweight Python base image
FROM python:3.11-slim

# Set working directory inside the container
WORKDIR /app

# Copy project files
COPY . .

# Install dependencies using 'uv sync' (reads pyproject.toml)
RUN pip install --no-cache-dir uv && \
    uv sync

# Expose the port your app will run on
EXPOSE 8080

# Run the FastAPI app
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8080"]
```

The above does the following: 


- **FROM python:3.11-slim**  
  Starts from a minimal Python image, keeping the container lightweight.

- **WORKDIR /app**  
  Sets the working directory inside the container. All subsequent commands run from this folder.

- **COPY . .**  
  Copies all project files (Python scripts, `pyproject.toml`, etc.) into the container.

- **RUN pip install --no-cache-dir uv && uv sync**  
  Installs `uv`, a modern dependency manager similar to Poetry or Pipenv.  
  `uv sync` reads the `pyproject.toml` file and installs all project dependencies.  
  Using `--no-cache-dir` reduces container size by not storing pip caches.

- **EXPOSE 8080**  
  Makes the container port 8080 available for mapping to the host machine or cloud.

- **CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8080"]**  
  Starts the FastAPI app using Uvicorn.  
  `0.0.0.0` ensures the app listens on all network interfaces, allowing access outside the container.

## Building an image

```bash
docker build -t pricing-app .
```

- -t pricing-app names the image pricing-app.

- . tells Docker to look for the Dockerfile in the current directory.

- Docker will execute all commands in the Dockerfile to create a portable image containing your code and dependencies.

## Run the container locally

```bash
docker run -p 8080:8080 pricing-app
```

- -p 8080:8080 maps the container’s port 8080 to your local machine, allowing you to access the FastAPI app in a browser at http://localhost:8080.

- This command executes the CMD from the Dockerfile (uvicorn app:app --host 0.0.0.0 --port 8080).

Verify the app is running locally:

```bash
curl http://localhost:8080/health
```

## Deploy to Azure container apps

```bash
az containerapp create \
  --name pricing-app \
  --resource-group my-resource-group \
  --image <dockerhub-username>/pricing-app:latest \
  --target-port 8080
```

