# 6.4. CI/CD

CI/CD stands for Continuous Integration and Continuous Deployment.

At its core, CI/CD is about automating the way code is built, tested, and deployed, so that changes flow smoothly from development to production without the delays, risks, and manual effort of traditional release processes.

In pricing and analytics teams, this can be especially powerful: instead of emailing around scripts, copying models into spreadsheets, or manually updating rating engines, CI/CD provides a repeatable, controlled pipeline to move from development to production safely.

---

## Why use CI/CD?

- Automation â€“ reduces manual steps in testing and deployment.  
- Reliability â€“ ensures changes meet quality standards before going live.  
- Speed â€“ faster turnaround from code changes to production impact.  
- Collaboration â€“ allows multiple analysts/developers to work on the same codebase without chaos.  
- Auditability â€“ provides a clear trail of what was changed, tested, and deployed.  
- Safety â€“ deployments are consistent, reducing the risk of errors from copy-paste or manual updates.  

---

## Continuous Integration (CI)

Continuous Integration is about bringing together code from multiple contributors in a controlled way.

- Every time code is committed, automated tests run to check that nothing is broken.  
- Teams can spot integration issues early rather than discovering them weeks later.  
- Code quality tools (e.g. linting, formatting, type checks) can be included in the pipeline.  
- For analytics: data quality checks and model validation tests can be built into CI.  

Example in Pricing:  
Every time an analyst updates a rating factor transformation script, CI runs unit tests to confirm outputs (e.g. age banding logic) still work correctly, and that the model still trains and scores without error.

---

## Continuous Deployment (CD)

Continuous Deployment automates the process of moving changes through testing environments and into production.

- After review and approval, code is automatically deployed to a production environment.  
- Reduces the time between developing a change and making it available to end users.  
- Ensures deployments are consistent every time, rather than relying on manual steps.  

Example in Pricing:  
When a new GLM model is approved, CD could automatically:  
- Deploy the model to a staging environment for user acceptance testing.  
- If approved, push it into the rating engine or API used in production.  
- Trigger monitoring dashboards to start tracking the modelâ€™s performance.  

---

## Tools

There are many tools to support CI/CD. Common ones include:  

- GitHub Actions â€“ integrates directly with GitHub for automation.  
- Azure DevOps â€“ widely used in enterprises, integrates with Microsoftâ€™s cloud.  
- GitLab CI/CD â€“ a strong open-source alternative.  
- Jenkins â€“ a flexible, older but still widely used tool.  

---

## Extensions for Analytics & Pricing

In addition to the standard software engineering practices, analytics teams can extend CI/CD to:  

- Data pipeline validation â€“ ensure new code doesnâ€™t break ETL or data extraction processes.  
- Model validation â€“ automatically check calibration, Gini, lift, or other key metrics before deployment.  
- Impact analysis checks â€“ simulate the effect of rating changes and ensure they are within expected ranges before approval.  
- Security scanning â€“ make sure dependencies and packages used are free of known vulnerabilities.  
- Documentation updates â€“ automatically build and publish documentation (e.g. model cards, assumptions, change logs).  


# Example Github Actions

```yaml
name: CI Pipeline  # ðŸ‘ˆ Name of the workflow

on:
  push:            # ðŸ‘ˆ Run workflow when code is pushed
    branches: [main]
  pull_request:    # ðŸ‘ˆ Also run when someone creates a PR into main
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest   # ðŸ‘ˆ Runner (virtual machine) where the job runs

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        # ðŸ‘† Pulls your repo code into the runner so we can work with it

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
        # ðŸ‘† Installs the version of Python you want to run your scripts with

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
        # ðŸ‘† Installs packages from your requirements.txt (numpy, pandas, polars, scikit-learn, etc.)

      - name: Run unit tests
        run: |
          pytest --maxfail=1 --disable-warnings -q
        # ðŸ‘† Runs tests with pytest. If one test fails, the pipeline stops.

      - name: Run linting
        run: |
          pip install flake8
          flake8 .
        # ðŸ‘† Code style / quality check. Helps keep code consistent across the team.

      - name: Run model validation checks
        run: |
          python tests/run_model_checks.py
        # ðŸ‘† Custom step: you might build a script to check model metrics, data integrity, or impact analysis

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test   # ðŸ‘ˆ Only runs if build-and-test succeeds
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Deploy to staging
        run: |
          echo "Deploying to staging..."
          # ðŸ‘† Replace with your actual deployment command (e.g. FastAPI app, Azure pipeline, or rating engine API update)

      - name: Notify team
        run: |
          echo "Deployment complete âœ…"
          # ðŸ‘† Could be extended to send a Slack/Teams message, email, etc.
```
