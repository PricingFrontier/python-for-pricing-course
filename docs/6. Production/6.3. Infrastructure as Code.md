# 6.3. Infrastructure as Code

Infrastructure as Code (IaC) means configuring cloud services and infrastructure using code, rather than manually pointing and clicking in a web console.  

The configuration lives in version-controlled code, right alongside the application or model code it supports which makes your infrastructure repeatable, auditable, and automated.

---

## Why use IaC?

- Consistency – ensure every environment (dev, test, prod) is set up identically.  
- Automation – spin up or tear down infrastructure with a single command.  
- Speed – new environments for models, APIs, or experiments can be created in minutes.  
- Versioning – infrastructure changes are tracked in Git, just like application code.  
- Collaboration – analysts and engineers can share the same definitions for how systems should run.  

---

## Example in Pricing

A pricing team wants to deploy a new CatBoost model into production:  

- With IaC, the cloud resources (compute instance, container registry, storage, networking) are defined in code.  
- The same code can create a test environment for validation, and later a production environment for live deployment.  
- If more compute power is needed, the configuration file can be updated and reapplied - no manual reconfiguration required.  

---

## Terraform

[Terraform](https://developer.hashicorp.com/terraform) is one of the most popular IaC tools. It uses configuration files (`.tf`) to define infrastructure in a cloud-agnostic way.  

---

## Example Terraform File

```terraform
# Define the provider (Azure in this case)
provider "azurerm" {
  features {}
}

# Resource group for pricing models
resource "azurerm_resource_group" "pricing" {
  name     = "pricing-rg"
  location = "UK South"
}

# Container instance to run our model API
resource "azurerm_container_group" "pricing_model" {
  name                = "pricing-model-api"
  location            = azurerm_resource_group.pricing.location
  resource_group_name = azurerm_resource_group.pricing.name
  os_type             = "Linux"

  container {
    name   = "model"
    image  = "myregistry.azurecr.io/pricing-model:latest"
    cpu    = "2"
    memory = "4"

    ports {
      port     = 8080
      protocol = "TCP"
    }
  }

  ip_address {
    type = "Public"
    ports {
      port     = 8080
      protocol = "TCP"
    }
  }
}
```

The above code: 


### 1. Configures provider  

   - `provider "azurerm" { features {} }` tells Terraform to use the Azure Resource Manager (azurerm) provider.  
   - This allows Terraform to create resources in Azure.

### 2. Creates a resource group  

   - `azurerm_resource_group.pricing` creates a Resource Group named `pricing-rg` in the UK South region.  
   - A resource group is a logical container for related Azure resources.

### 3. Creates an Azure Container Instance (ACI) group  

   - `azurerm_container_group.pricing_model` creates a container group called `pricing-model-api` inside the `pricing-rg` resource group.  
   - It runs on Linux and inherits the resource group’s location.

### 4. Defines the container inside the group  

   - The `container` block defines a single container named `model`.  
   - It pulls the Docker image `myregistry.azurecr.io/pricing-model:latest`.  
   - Allocates 2 CPUs and 4 GB memory.  
   - Exposes port 8080/TCP inside the container for the application.

### 5. Exposes the container group publicly  

   - The `ip_address` block assigns a Public IP address to the container group.  
   - It maps port 8080/TCP from the public IP to the container.  
   - After deployment, the API is reachable over the internet on port 8080.

### 6. What happens when you run `terraform apply`? 

   - Terraform creates the resource group.  
   - Terraform provisions the container group and starts the container.  
   - Azure assigns a public IP, and requests to port 8080 are routed to the container.