# 3.0. Syntax

Before diving into building pricing models and analytics, it’s essential to master Python’s core programming concepts. This section introduces basic syntax, illustrated with insurance pricing examples.

# Variables and Data Types

We can store values as python variables, these can simply be numbers, strings, booleans, or can be more complex such as lists, dictionaries, or whole datasets, classes, models. 

```python
# Example variables
minimum_premium_new_business = 100.00   # float
model_response = "ClaimCount"           # string
renewal_flag = True                     # boolean
```

# Basic Operations
```python

# Calculations
loss_ratio = total_incurred_losses / net_earned_premium


if is_high_risk:
    print("Apply additional underwriting review")
elif eligible_for_discount:
    print("Apply loyalty discount")
else:
    print("Standard premium applies")
```


# Lists

Allows us to loop through. 

```python
features = [
    "a",
    "b",
    "c",
    "d",
    "e"
]
```

Or we can create these dynamically. 

```python
features = feature_data.columns
```

If we want to be doing anything repetitive

```python
import polars as pl

# Fill nulls in X_train
for col in data.select(features).columns:
    if data.schema[col] == pl.Utf8:
        data = data.with_columns(pl.col(col).fill_null('missing'))
    else:
        data = data.with_columns(pl.col(col).fill_null(0))
```

# Dictionaries

```python
dictionary = {
    "competitor_model": competitor_features,
    "instalment_model": instalment_features
}
```

# Control Flow - if Statements

```python
# List of customer premiums
premiums = [500, 650, 420, 700]

# Print each premium
for premium in premiums:
    print(f"Premium amount: ${premium}")
```

# Loops - for and while

```python
# Calculate total premiums collected using a while loop
total = 0
index = 0
while index < len(premiums):
    total += premiums[index]
    index += 1
print(f"Total premiums: ${total}")
```

# Abstraction

Abstraction is when we put more complex logic into functions, classes or libraries, allowing us to use a simple interface to write out code.

Rather than writing single complicated scripts, by creating functions for each task, we can simplify the overall workflow, promoting reusability across the codebase.

# Functions
```python
def calculate_premium(base, risk, claim_history):
    premium = base * risk
    if claim_history:
        premium *= 1.2  # 20% surcharge for prior claims
    return premium

# Example usage
customer_premium = calculate_premium(500, 1.15, False)
print(f"Calculated premium: ${customer_premium}")
```

# Configuration

