# 6.6. CI/CD

CI/CD stands for Continuous Integration and Continuous Deployment.

At its core, CI/CD is about automating the way code is built, tested, and deployed, so that changes flow smoothly from development to production without the delays, risks, and manual effort of traditional release processes.

In pricing and analytics teams, this can be especially powerful: instead of emailing around scripts, copying models into spreadsheets, or manually updating rating engines, CI/CD provides a repeatable, controlled pipeline to move from development to production safely.

---

## Why use CI/CD?

- Automation – reduces manual steps in testing and deployment.  
- Reliability – ensures changes meet quality standards before going live.  
- Speed – faster turnaround from code changes to production impact.  
- Collaboration – allows multiple analysts/developers to work on the same codebase without chaos.  
- Auditability – provides a clear trail of what was changed, tested, and deployed.  
- Safety – deployments are consistent, reducing the risk of errors from copy-paste or manual updates.  

---

## Continuous Integration (CI)

Continuous Integration is about bringing together code from multiple contributors in a controlled way.

- Every time code is committed, automated tests run to check that nothing is broken.  
- Teams can spot integration issues early rather than discovering them weeks later.  
- Code quality tools (e.g. linting, formatting, type checks) can be included in the pipeline.  
- For analytics: data quality checks and model validation tests can be built into CI.  

Example in Pricing:  
Every time an analyst updates a rating factor transformation script, CI runs unit tests to confirm outputs (e.g. age banding logic) still work correctly, and that the model still trains and scores without error.

---

## Continuous Deployment (CD)

Continuous Deployment automates the process of moving changes through testing environments and into production.

- After review and approval, code is automatically deployed to a production environment.  
- Reduces the time between developing a change and making it available to end users.  
- Ensures deployments are consistent every time, rather than relying on manual steps.  

Example in Pricing:  
When a new GLM model is approved, CD could automatically:  
- Deploy the model to a staging environment for user acceptance testing.  
- If approved, push it into the rating engine or API used in production.  
- Trigger monitoring dashboards to start tracking the model’s performance.  

---

## Tools

There are many tools to support CI/CD. Common ones include:  

- GitHub Actions – integrates directly with GitHub for automation.  
- Azure DevOps – widely used in enterprises, integrates with Microsoft’s cloud.  
- GitLab CI/CD – a strong open-source alternative.  
- Jenkins – a flexible, older but still widely used tool.  

---

## Extensions for Analytics & Pricing

In addition to the standard software engineering practices, analytics teams can extend CI/CD to:  

- Data pipeline validation – ensure new code doesn’t break ETL or data extraction processes.  
- Model validation – automatically check calibration, Gini, lift, or other key metrics before deployment.  
- Impact analysis checks – simulate the effect of rating changes and ensure they are within expected ranges before approval.  
- Security scanning – make sure dependencies and packages used are free of known vulnerabilities.  
- Documentation updates – automatically build and publish documentation (e.g. model cards, assumptions, change logs).  


# Example Github Actions

```yaml
name: CI/CD FastAPI to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  IMAGE_NAME: fastapi-mlflow
  RESOURCE_GROUP: demo-fastapi
  CONTAINER_APP: pricingdemo-fastapi
  ACR_NAME: pricingdemofastapiregistry
  LOCATION: "UK South"

jobs:
  deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      # -------------------------
      # Checkout code
      # -------------------------
      - name: Checkout code
        uses: actions/checkout@v3

      # -------------------------
      # Setup Python
      # -------------------------
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      # -------------------------
      # Setup Terraform
      # -------------------------
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.8.0

      # -------------------------
      # Azure Login
      # -------------------------
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # -------------------------
      # Terraform Init
      # -------------------------
      - name: Terraform Init
        run: terraform init

      # -------------------------
      # Terraform Plan
      # -------------------------
      - name: Terraform Plan
        run: terraform plan -out=tfplan -input=false

      # -------------------------
      # Terraform Apply
      # -------------------------
      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan

      # -------------------------
      # Set Docker Image Tag based on commit SHA
      # -------------------------
      - name: Set Docker image tag
        run: echo "IMAGE_TAG=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_ENV

      # -------------------------
      # Build Docker image
      # -------------------------
      - name: Build Docker image
        run: |
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .

      # -------------------------
      # Login to ACR
      # -------------------------
      - name: Login to Azure Container Registry
        run: |
          az acr login --name ${{ env.ACR_NAME }}

      # -------------------------
      # Push Docker image to ACR
      - name: Push Docker image
        run: |
          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      # -------------------------
      # Update Container App image
      # -------------------------
      - name: Update Container App
        run: |
          az containerapp update \
            --name ${{ env.CONTAINER_APP }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}


```

This workflow uses Docker and `uv` to ensure consistent testing, linting, and deployment of Python pricing applications.

---

### Build and Test Job

**1. Checkout repository**  
Pulls your GitHub repository code into the runner so Docker can build the image.

**2. Build Docker image**  
Creates a Docker image called `pricing-app` using the `Dockerfile` in your repo. This packages your application, dependencies, and environment in a reproducible container.

**3. Run unit tests inside container**  
Runs `pytest` inside the Docker container using `uv run` to install dependencies from `pyproject.toml` and execute tests. Ensures tests run in the same environment as production.

**4. Run linting inside container**  
Executes `flake8` inside the Docker container to check code style and maintain consistency across the team.

**5. Run model validation checks**  
Runs custom Python scripts (`tests/run_model_checks.py`) inside the container to validate model outputs, data integrity, or other pricing-specific checks.

---

### Deploy Job

**1. Checkout repository**  
Pulls the latest code from the main branch to prepare for deployment.

**2. Build Docker image for deployment**  
Rebuilds the container image (`pricing-app`) to ensure deployment uses the latest code and dependencies.

**3. Push Docker image to registry**  
Logs into your Docker registry and pushes the container image so it can be deployed anywhere (Azure, Kubernetes, etc.).

**4. Deploy to staging**  
Starts or updates the container in the staging environment. This can be replaced with Azure CLI, Kubernetes commands, or Docker run commands depending on your deployment setup.

**5. Notify team**  
Optional step to inform the team that deployment has completed successfully (via echo, Slack, Teams, or email).

---
