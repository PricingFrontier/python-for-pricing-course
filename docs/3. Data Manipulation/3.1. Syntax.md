# 3.1. Syntax

Before diving into building pricing models and analytics, it’s essential to master Python’s core programming concepts. This section introduces basic syntax, illustrated with insurance pricing examples.

## Variables and Data Types

We can store values as python variables, these can simply be numbers, strings, booleans, or can be more complex such as lists, arrays, dictionaries, whole datasets, models, etc. 

```python
# Example variables
minimum_premium_new_business = 100.00   # float
model_response = 'ClaimCount'           # string
renewal_flag = True                     # boolean
```

## Basic Operations
```python

# Calculations
loss_ratio = total_incurred_losses / net_earned_premium

# String manipulations - we can put braces {} when defining a string, and place other string variables within them.
database = 'SQL001'
schema = 'pricing'
table = 'modelling_data'

query = f'select * from [{database}].[{schema}].[{table}]'
# 'select * from [SQL001].[pricing].[modelling_data]'

```

Lists are groups of Python objects. They are ordered, indexable, and can be looped through or manipulated.

```python
features = [
    'DriverAge',
    'LicenceLength',
    'VehicleAge',
    'VehicleValue'
]

net_earned_premiums = [
    42.44,
    129.98,
    87.49,
    54.34,
    210.85
]
```

## Dictionaries 
Dictionaries store Python objects using key-value pairs. Keys are usually strings, while values can be any object (numbers, strings, lists, other dictionaries).

```python
feature_config = {
    'DriverAge': 'continous',
    'LicenceLength': 'continous',
    'VehicleType': 'categorical',
    'VehicleAge': 'continous',
    'VehicleValue': 'continous',
    'ClassOfUse': 'categorical'
}
```

They can be programmatically assigned as so:

```python
dict = {}
dict[key] = value
```

Values can be retrieved as so:

```python
feature_config.get('DriverAge')
```

Dictionaries can be nested, making them extremely useful for storing model configurations, hyperparameters, or mappings between codes and descriptions.

## Conditions

```python
if renewal_flag = True:
    print('The policy is a renewal')
else eligible_for_discount:
    print('The policy is a new business')
```


## Loops

```python
total = 0
for premium in premiums:
    total += premium

print(f'Total premiums: ${total:.2f}')
```

## Abstraction

Abstraction is when we put more complex logic into functions, classes or libraries, allowing us to use a simple interface to write out code.

Rather than writing single complicated scripts, by creating functions for each task, we can simplify the overall workflow, promoting reusability across the codebase.

## Functions

```python
def calculate_burning_cost(claims, exposure):
    """Return burning cost = claims / exposure"""
    return claims / exposure

# Example usage
claims = 120000
exposure = 1500  # car-years
print(calculate_burning_cost(claims, exposure))  # 80.0
```

## Configuration

Rather than hardcoding numbers (like minimum premiums or loadings), we store them in configuration files or dictionaries.
This allows analysts to change parameters without editing core logic.

```python
pricing_config = {
    'MinimumPremium': 100.0,
    'YoungDriverLoading': 1.25,
    'HighValueVehicleLoading': 1.5
}

def apply_pricing_rules(premium, config):
    premium = max(premium, config['MinimumPremium'])
    return premium

print(apply_pricing_rules(80, pricing_config))  # 100.0
```