# 6.5. CI/CD

CI/CD stands for Continuous Integration and Continuous Deployment.

At its core, CI/CD is about automating the way code is built, tested, and deployed, so that changes flow smoothly from development to production without the delays, risks, and manual effort of traditional release processes.

In pricing and analytics teams, this can be especially powerful: instead of emailing around scripts, copying models into spreadsheets, or manually updating rating engines, CI/CD provides a repeatable, controlled pipeline to move from development to production safely.

---

## Why use CI/CD?

- Automation – reduces manual steps in testing and deployment.  
- Reliability – ensures changes meet quality standards before going live.  
- Speed – faster turnaround from code changes to production impact.  
- Collaboration – allows multiple analysts/developers to work on the same codebase without chaos.  
- Auditability – provides a clear trail of what was changed, tested, and deployed.  
- Safety – deployments are consistent, reducing the risk of errors from copy-paste or manual updates.  

---

## Continuous Integration (CI)

Continuous Integration is about bringing together code from multiple contributors in a controlled way.

- Every time code is committed, automated tests run to check that nothing is broken.  
- Teams can spot integration issues early rather than discovering them weeks later.  
- Code quality tools (e.g. linting, formatting, type checks) can be included in the pipeline.  
- For analytics: data quality checks and model validation tests can be built into CI.  

Example in Pricing:  
Every time an analyst updates a rating factor transformation script, CI runs unit tests to confirm outputs (e.g. age banding logic) still work correctly, and that the model still trains and scores without error.

---

## Continuous Deployment (CD)

Continuous Deployment automates the process of moving changes through testing environments and into production.

- After review and approval, code is automatically deployed to a production environment.  
- Reduces the time between developing a change and making it available to end users.  
- Ensures deployments are consistent every time, rather than relying on manual steps.  

Example in Pricing:  
When a new GLM model is approved, CD could automatically:  
- Deploy the model to a staging environment for user acceptance testing.  
- If approved, push it into the rating engine or API used in production.  
- Trigger monitoring dashboards to start tracking the model’s performance.  

---

## Tools

There are many tools to support CI/CD. Common ones include:  

- GitHub Actions – integrates directly with GitHub for automation.  
- Azure DevOps – widely used in enterprises, integrates with Microsoft’s cloud.  
- GitLab CI/CD – a strong open-source alternative.  
- Jenkins – a flexible, older but still widely used tool.  

---

## Extensions for Analytics & Pricing

In addition to the standard software engineering practices, analytics teams can extend CI/CD to:  

- Data pipeline validation – ensure new code doesn’t break ETL or data extraction processes.  
- Model validation – automatically check calibration, Gini, lift, or other key metrics before deployment.  
- Impact analysis checks – simulate the effect of rating changes and ensure they are within expected ranges before approval.  
- Security scanning – make sure dependencies and packages used are free of known vulnerabilities.  
- Documentation updates – automatically build and publish documentation (e.g. model cards, assumptions, change logs).  


# Example Github Actions

```yaml
name: CI Pipeline

on:
  push:            
    branches: [main]
  pull_request:    
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Build Docker image
        run: |
          docker build -t pricing-app .

      - name: Run unit tests inside container
        run: |
          docker run --rm pricing-app uv run pytest --maxfail=1 --disable-warnings -q

      - name: Run linting inside container
        run: |
          docker run --rm pricing-app uv run flake8 .

      - name: Run model validation checks
        run: |
          docker run --rm pricing-app uv run python tests/run_model_checks.py

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Build Docker image for deployment
        run: |
          docker build -t pricing-app .

      - name: Push Docker image to registry
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker tag pricing-app ${{ secrets.DOCKER_USERNAME }}/pricing-app:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/pricing-app:latest

      - name: Deploy to staging
        run: |
          echo "Deploying Docker container to staging..."
          # Replace with Azure CLI, Kubernetes, or Docker run commands

      - name: Notify team
        run: |
          echo "Deployment complete ✅"

```

This workflow uses Docker and `uv` to ensure consistent testing, linting, and deployment of Python pricing applications.

---

### Build and Test Job

**1. Checkout repository**  
Pulls your GitHub repository code into the runner so Docker can build the image.

**2. Build Docker image**  
Creates a Docker image called `pricing-app` using the `Dockerfile` in your repo. This packages your application, dependencies, and environment in a reproducible container.

**3. Run unit tests inside container**  
Runs `pytest` inside the Docker container using `uv run` to install dependencies from `pyproject.toml` and execute tests. Ensures tests run in the same environment as production.

**4. Run linting inside container**  
Executes `flake8` inside the Docker container to check code style and maintain consistency across the team.

**5. Run model validation checks**  
Runs custom Python scripts (`tests/run_model_checks.py`) inside the container to validate model outputs, data integrity, or other pricing-specific checks.

---

### Deploy Job

**1. Checkout repository**  
Pulls the latest code from the main branch to prepare for deployment.

**2. Build Docker image for deployment**  
Rebuilds the container image (`pricing-app`) to ensure deployment uses the latest code and dependencies.

**3. Push Docker image to registry**  
Logs into your Docker registry and pushes the container image so it can be deployed anywhere (Azure, Kubernetes, etc.).

**4. Deploy to staging**  
Starts or updates the container in the staging environment. This can be replaced with Azure CLI, Kubernetes commands, or Docker run commands depending on your deployment setup.

**5. Notify team**  
Optional step to inform the team that deployment has completed successfully (via echo, Slack, Teams, or email).

---
