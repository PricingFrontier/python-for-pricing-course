# 0.3. Innovation

It is very difficult to be truly innovative when you are restricted to pre-built, off-the-shelf solutions.  

While commercial pricing tools have their place, they are designed to fit the needs of many companies at once. That means they are built for the "average" pricing process - not for the unique strategy that could give your business a competitive edge.

---

## Everyone using the same paid software has the same capabilities

If you are using the same pricing software as all your competitors - with the same risk factors, the same external data integrations, and the same modelling options - you are starting from an identical foundation.  

When every insurer’s toolkit is essentially the same, any difference in strategy comes down to how the tool is used. But in practice, most teams use these tools in similar ways, leading to:

- Pricing convergence - everyone’s rates start looking the same.
- Limited scope for unique segmentation or novel data usage.
- A “race to the bottom” on price, rather than differentiation through value or insight.

By moving to a more flexible, code-driven approach, you can design features, models, and workflows that competitors simply can’t replicate without significant internal effort.

---

## Pricing complexity demands flexible solutions

Regulatory requirements, competitive pressures, and evolving distribution channels often mean pricing strategies are far more nuanced than the base capabilities of paid software allow.  

This often leads to:
- Workarounds that are cumbersome and hard to maintain.
- Suboptimal pricing logic because the tool can’t handle the required complexity.
- Decisions being constrained by the software rather than by the business need.

With code, these same “edge cases” are often straightforward:
- Complex eligibility rules? Easy to implement in Python logic.
- Multiple interacting model outputs? Simple to combine in a pipeline.
- Tailored pricing adjustments? Fully customisable without waiting for vendor updates.

---

## Leveraging advances in data science for pricing

The world of data science moves fast - far faster than most commercial pricing tools update.  

Cutting-edge techniques like:
- Gradient boosting and automated hyperparameter tuning.
- Real-time model scoring in cloud environments.
- Machine learning explainability tools for regulatory compliance.

…are often available in open-source Python libraries years before they appear in paid pricing software.

By building pricing capabilities in Python, you can:
- Test and deploy new modelling techniques quickly.
- Take advantage of advances in feature engineering, simulation, and optimisation.
- Integrate seamlessly with emerging data sources and APIs.

---

## Future-proofing your pricing capabilities

Code-based pricing workflows are inherently adaptable. As markets, regulations, and technology evolve, you can:
- Modify your code to accommodate new rules or products.
- Experiment with new modelling techniques without waiting for software updates.
- Scale up processing power in the cloud as data volumes grow.

This means your pricing infrastructure can evolve with your business - rather than locking you into the release cycle of a software vendor.

---

## Example: From constraint to capability

Constraint: A commercial pricing tool limits risk factor granularity to a set number of bands.  
With code: You can implement dynamic risk banding based on statistical thresholds, updated automatically as new data arrives.

Constraint: Paid software supports only a small set of machine learning models.  
With code: You can try LightGBM, XGBoost, CatBoost, GAMs, or even neural networks - all using open-source libraries.

Constraint: Reports must be manually generated and exported.  
With code: Automated pipelines can run, update, and distribute reports without human intervention.

---

In short:  
Code gives you the ability to differentiate your pricing approach, adopt new innovations faster, and build solutions tailored exactly to your business - not the average of your competitors.
